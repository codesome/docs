---
title: Subquery
created_at: 2018-12-28
kind: article
author_name: Ganesh Vernekar
---

## Introduction

As the title suggests, subquery is a part of a query, and allows you to do a range query within a query, which was not possible before. It has been a long standing request on Prometheus [prometheus/prometheus/1227](https://github.com/prometheus/prometheus/issues/1227) and a desired feature.

PR for subquery was recently merged into Prometheus [prometheus/prometheus/4831](https://github.com/prometheus/prometheus/pull/4831), and will be available in Prometheus 2.7 release. Letâ€™s learn more about it below.

## Motivation

Previously if you wanted to have a range selection on a query for your alerting rule or graphing, it would require you to have a recording rule based on that query, and perform range selection on the recording rule.

When you want some quick results on data spanning days or weeks, it can be quite a bit of wait till you have enough data in your recording rules before it can be used. Forgetting to add recording rules can be frustrating. And would be tedious to create a recording rule for each step of a query.

With subquery, all the wait and frustration is taken care of.

## Subquery

Subquery is similar to [/api/v1/query_range](https://prometheus.io/docs/prometheus/latest/querying/api/#range-queries) API call, but embedded within an instant query.

Prometheus team arrived at a consensus for the syntax of subquery in Prometheus Dev Summit 2018 held in Munich. This is the [notes of the summit on subquery](https://docs.google.com/document/d/1-C5PycocOZEVIPrmM1hn8fBelShqtqiAmFptoG4yK70/edit#heading=h.q32gdnoqz8t0), and a brief [design doc for the syntax](https://docs.google.com/document/d/1P_G87zN88YvmMr4iwLWygChMTZhai1L7S_c0awu1CAE/edit?usp=sharing) used for implementing subquery.

    <instant_query> '[' <range> ':' [ <resolution> ] ']' [ offset <duration> ]

* `<instant_query>` is equivalent to `query` field in `/query_range` API.
* `<range>` and `offset <duration>` is similar to a range selector.
* `<resolution>` is optional, which is equivalent to `step` in `/query_range` API.

When the resolution is not specified, the global evaluation interval is taken as the default resolution for the subquery. Also, the step of the subquery is aligned independently, and does not depend on the parent query's eval time.

## Examples

This query returns 5-minute rate of metric for the past 30 minute, at a resolution of 1 minute. This would be equivalent to a query_range API call with `query=rate(http_requests_total[5m]), end=<now>, start=<now>-30m, step=1m`.

    rate(http_requests_total[5m])[30m:1m]

Following is an example of a nested subquery, and usage of default resolution. The innermost subquery gets the rate of `distance_covered_total` over a range of time. We use that to get deriv of the rates, again for a range of time. And finally take the max of all the deriv.
Note that the `<now>` time for the innermost subquery is relative to the evaluation time of the outer subquery on deriv.

    max_over_time( deriv( rate(distance_covered_total[5s])[30s:5s] )[10m:] )

## Epilogue

Though subquery is very convenient to use in place of recording rule, using it unnecessarily is unwise. Heavy subqueries should be eventually converted to recording rules.
